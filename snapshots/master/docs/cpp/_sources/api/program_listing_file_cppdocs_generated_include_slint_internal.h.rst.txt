
.. _program_listing_file_cppdocs_generated_include_slint_internal.h:

Program Listing for File slint_internal.h
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file_cppdocs_generated_include_slint_internal.h>` (``cppdocs/generated_include/slint_internal.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   /* Generated with cbindgen:0.26.0 */
   
   #include <cstdarg>
   #include <cstdint>
   #include <cstdlib>
   #include <ostream>
   #include <new>
   #include "slint_config.h"
   #include "vtable.h"
   #include "slint_string.h"
   #include "slint_sharedvector.h"
   #include "slint_properties.h"
   #include "slint_callbacks.h"
   #include "slint_color.h"
   #include "slint_image.h"
   #include "slint_pathdata.h"
   #include "slint_brush.h"
   #include "slint_generated_public.h"
   #include "slint_enums_internal.h"
   #include "slint_point.h"
   #include "slint_timer.h"
   #include "slint_builtin_structs_internal.h"
   
   namespace slint {
       namespace private_api { class WindowAdapterRc; }
       namespace cbindgen_private {
           using slint::private_api::WindowAdapterRc;
           using namespace vtable;
           struct KeyEvent; struct PointerEvent;
           using private_api::Property;
           using private_api::PathData;
           using private_api::Point;
           struct Rect;
           using LogicalRect = Rect;
           using LogicalPoint = Point2D<float>;
           using LogicalLength = float;
           struct ItemTreeVTable;
           struct ItemVTable;
           using types::IntRect;
       }
       template<typename ModelData> class Model;
   }
   
   namespace slint {
   namespace cbindgen_private {
   
   constexpr static const uintptr_t PHYSICAL_REGION_MAX_SIZE = 3;
   
   enum class AccessibleStringProperty : uint32_t {
       Checkable,
       Checked,
       DelegateFocus,
       Description,
       Enabled,
       Label,
       PlaceholderText,
       PositionInSet,
       Selectable,
       Selected,
       SizeOfSet,
       Value,
       ValueMaximum,
       ValueMinimum,
       ValueStep,
   };
   
   enum class Clipboard : uint8_t {
       DefaultClipboard = 0,
       SelectionClipboard = 1,
   };
   
   enum class FocusEvent : uint8_t {
       FocusIn,
       FocusOut,
       WindowReceivedFocus,
       WindowLostFocus,
   };
   
   enum class FocusEventResult : uint8_t {
       FocusAccepted,
       FocusIgnored,
   };
   
   enum class InputEventResult : uint8_t {
       EventAccepted,
       EventIgnored,
       GrabMouse,
   };
   
   enum class KeyEventResult : uint8_t {
       EventAccepted,
       EventIgnored,
   };
   
   enum class KeyEventType : uint8_t {
       KeyPressed = 0,
       KeyReleased = 1,
       UpdateComposition = 2,
       CommitComposition = 3,
   };
   
   enum class RenderingResult {
       ContinueRenderingChildren,
       ContinueRenderingWithoutChildren,
   };
   
   enum class TraversalOrder : uint8_t {
       BackToFront,
       FrontToBack,
   };
   
   enum class UndoItemKind {
       TextInsert,
       TextRemove,
   };
   
   struct ChangeTracker;
   
   struct FlickableData;
   
   struct ItemRendererRef;
   
   template<typename T = void>
   struct Option;
   
   struct PhysicalPx;
   
   using VisitChildrenResult = uint64_t;
   constexpr static const VisitChildrenResult VisitChildrenResult_CONTINUE = UINT64_MAX;
   
   struct ItemRc {
       VRc<ItemTreeVTable> item_tree;
       uint32_t index;
   };
   
   struct LayoutInfo {
       float max;
       float max_percent;
       float min;
       float min_percent;
       float preferred;
       float stretch;
       inline LayoutInfo merge(const LayoutInfo &other) const;
       friend inline LayoutInfo operator+(const LayoutInfo &a, const LayoutInfo &b) { return a.merge(b); }
       friend bool operator==(const LayoutInfo&, const LayoutInfo&) = default;
   };
   
   struct InputEventFilterResult {
       enum class Tag {
           ForwardEvent,
           ForwardAndIgnore,
           ForwardAndInterceptGrab,
           Intercept,
           DelayForwarding,
       };
   
       struct DelayForwarding_Body {
           uint64_t _0;
       };
   
       Tag tag;
       union {
           DelayForwarding_Body delay_forwarding;
       };
   };
   
   struct MouseEvent {
       enum class Tag {
           Pressed,
           Released,
           Moved,
           Wheel,
           Exit,
       };
   
       struct Pressed_Body {
           LogicalPoint position;
           PointerEventButton button;
           uint8_t click_count;
       };
   
       struct Released_Body {
           LogicalPoint position;
           PointerEventButton button;
           uint8_t click_count;
       };
   
       struct Moved_Body {
           LogicalPoint position;
       };
   
       struct Wheel_Body {
           LogicalPoint position;
           float delta_x;
           float delta_y;
       };
   
       Tag tag;
       union {
           Pressed_Body pressed;
           Released_Body released;
           Moved_Body moved;
           Wheel_Body wheel;
       };
   };
   
   struct LogicalSize {
       float width;
       float height;
   };
   
   struct ItemVTable {
       void (*init)(Pin<VRef<ItemVTable>>, const ItemRc *my_item);
       uintptr_t cached_rendering_data_offset;
       LayoutInfo (*layout_info)(Pin<VRef<ItemVTable>>,
                                 Orientation orientation,
                                 const WindowAdapterRc *window_adapter);
       InputEventFilterResult (*input_event_filter_before_children)(Pin<VRef<ItemVTable>>,
                                                                    MouseEvent,
                                                                    const WindowAdapterRc *window_adapter,
                                                                    const ItemRc *self_rc);
       InputEventResult (*input_event)(Pin<VRef<ItemVTable>>,
                                       MouseEvent,
                                       const WindowAdapterRc *window_adapter,
                                       const ItemRc *self_rc);
       FocusEventResult (*focus_event)(Pin<VRef<ItemVTable>>,
                                       const FocusEvent*,
                                       const WindowAdapterRc *window_adapter,
                                       const ItemRc *self_rc);
       KeyEventResult (*key_event)(Pin<VRef<ItemVTable>>,
                                   const KeyEvent*,
                                   const WindowAdapterRc *window_adapter,
                                   const ItemRc *self_rc);
       RenderingResult (*render)(Pin<VRef<ItemVTable>>,
                                 ItemRendererRef *backend,
                                 const ItemRc *self_rc,
                                 LogicalSize size);
   };
   
   struct ItemVisitorVTable {
       VisitChildrenResult (*visit_item)(VRefMut<ItemVisitorVTable>,
                                         const VRc<ItemTreeVTable, Dyn> *item_tree,
                                         uint32_t index,
                                         Pin<VRef<ItemVTable>> item);
       void (*drop)(VRefMut<ItemVisitorVTable>);
   };
   
   struct IndexRange {
       uintptr_t start;
       uintptr_t end;
   };
   
   union ItemTreeNode {
       enum class Tag : uint8_t {
           Item,
           DynamicTree,
       };
   
       struct Item_Body {
           Tag tag;
           bool is_accessible;
           uint32_t children_count;
           uint32_t children_index;
           uint32_t parent_index;
           uint32_t item_array_index;
       };
   
       struct DynamicTree_Body {
           Tag tag;
           uint32_t index;
           uint32_t parent_index;
       };
   
       struct {
           Tag tag;
       };
       Item_Body item;
       DynamicTree_Body dynamic_tree;
       constexpr ItemTreeNode(Item_Body x) : item {x} {}
       constexpr ItemTreeNode(DynamicTree_Body x) : dynamic_tree{x} {}
   };
   
   using ItemTreeWeak = VWeak<ItemTreeVTable, Dyn>;
   
   struct ItemWeak {
       ItemTreeWeak item_tree;
       uint32_t index;
   };
   
   union AccessibilityAction {
       enum class Tag : uint32_t {
           Default,
           Decrement,
           Increment,
           ReplaceSelectedText,
           SetValue,
       };
   
       struct ReplaceSelectedText_Body {
           Tag tag;
           SharedString _0;
       };
   
       struct SetValue_Body {
           Tag tag;
           SharedString _0;
       };
   
       struct {
           Tag tag;
       };
       ReplaceSelectedText_Body replace_selected_text;
       SetValue_Body set_value;
   };
   
   using SupportedAccessibilityAction = uint32_t;
   constexpr static const SupportedAccessibilityAction SupportedAccessibilityAction_Default = (uint32_t)1;
   constexpr static const SupportedAccessibilityAction SupportedAccessibilityAction_Decrement = (uint32_t)(1 << 1);
   constexpr static const SupportedAccessibilityAction SupportedAccessibilityAction_Increment = (uint32_t)(1 << 2);
   constexpr static const SupportedAccessibilityAction SupportedAccessibilityAction_ReplaceSelectedText = (uint32_t)(1 << 3);
   constexpr static const SupportedAccessibilityAction SupportedAccessibilityAction_SetValue = (uint32_t)(1 << 4);
   
   struct ItemTreeVTable {
       VisitChildrenResult (*visit_children_item)(Pin<VRef<ItemTreeVTable>>,
                                                  intptr_t index,
                                                  TraversalOrder order,
                                                  VRefMut<ItemVisitorVTable> visitor);
       Pin<VRef<ItemVTable>> (*get_item_ref)(Pin<VRef<ItemTreeVTable>>, uint32_t index);
       IndexRange (*get_subtree_range)(Pin<VRef<ItemTreeVTable>>, uint32_t index);
       void (*get_subtree)(Pin<VRef<ItemTreeVTable>>,
                           uint32_t index,
                           uintptr_t subindex,
                           VWeak<ItemTreeVTable, Dyn> *result);
       Slice<ItemTreeNode> (*get_item_tree)(Pin<VRef<ItemTreeVTable>>);
       void (*parent_node)(Pin<VRef<ItemTreeVTable>>, ItemWeak *result);
       bool (*embed_component)(Pin<VRef<ItemTreeVTable>>,
                               const VWeak<ItemTreeVTable> *parent,
                               uint32_t parent_item_tree_index);
       uintptr_t (*subtree_index)(Pin<VRef<ItemTreeVTable>>);
       LayoutInfo (*layout_info)(Pin<VRef<ItemTreeVTable>>, Orientation);
       LogicalRect (*item_geometry)(Pin<VRef<ItemTreeVTable>>, uint32_t item_index);
       AccessibleRole (*accessible_role)(Pin<VRef<ItemTreeVTable>>, uint32_t item_index);
       bool (*accessible_string_property)(Pin<VRef<ItemTreeVTable>>,
                                          uint32_t item_index,
                                          AccessibleStringProperty what,
                                          SharedString *result);
       void (*accessibility_action)(Pin<VRef<ItemTreeVTable>>,
                                    uint32_t item_index,
                                    const AccessibilityAction *action);
       SupportedAccessibilityAction (*supported_accessibility_actions)(Pin<VRef<ItemTreeVTable>>,
                                                                       uint32_t item_index);
       bool (*item_element_infos)(Pin<VRef<ItemTreeVTable>>, uint32_t item_index, SharedString *result);
       void (*window_adapter)(Pin<VRef<ItemTreeVTable>>,
                              bool do_create,
                              Option<WindowAdapterRc> *result);
       Layout (*drop_in_place)(VRefMut<ItemTreeVTable>);
       void (*dealloc)(const ItemTreeVTable*, uint8_t *ptr, Layout layout);
   };
   
   using ItemTreeRc = VRc<ItemTreeVTable, Dyn>;
   
   struct WindowAdapterRcOpaque {
       const void *_0;
       const void *_1;
   };
   
   using ItemTreeRef = VRef<ItemTreeVTable>;
   
   using ItemTreeRefPin = Pin<ItemTreeRef>;
   
   struct FlickableDataBox {
   struct FlickableData;
       FlickableData *_0;
   };
   
   struct PreEditSelection {
       bool valid;
       int32_t start;
       int32_t end;
   };
   
   struct CachedRenderingData {
       uintptr_t cache_index;
       uintptr_t cache_generation;
       constexpr CachedRenderingData() : cache_index{}, cache_generation{} {}
   };
   
   struct UndoItem {
       uintptr_t pos;
       SharedString text;
       uintptr_t cursor;
       uintptr_t anchor;
       UndoItemKind kind;
   };
   
   struct TextInput {
       Property<SharedString> text;
       Property<SharedString> font_family;
       Property<LogicalLength> font_size;
       Property<int32_t> font_weight;
       Property<bool> font_italic;
       Property<Brush> color;
       Property<Color> selection_foreground_color;
       Property<Color> selection_background_color;
       Property<TextHorizontalAlignment> horizontal_alignment;
       Property<TextVerticalAlignment> vertical_alignment;
       Property<TextWrap> wrap;
       Property<InputType> input_type;
       Property<LogicalLength> letter_spacing;
       Property<LogicalLength> width;
       Property<LogicalLength> height;
       Property<int32_t> cursor_position_byte_offset;
       Property<int32_t> anchor_position_byte_offset;
       Property<LogicalLength> text_cursor_width;
       Property<bool> cursor_visible;
       Property<bool> has_focus;
       Property<bool> enabled;
       private_api::CallbackHelper<void> accepted;
       private_api::CallbackHelper<void> rejected;
       private_api::CallbackHelper<slint::LogicalPosition> cursor_position_changed;
       private_api::CallbackHelper<void> edited;
       Property<bool> single_line;
       Property<bool> read_only;
       Property<SharedString> preedit_text;
       Property<PreEditSelection> preedit_selection;
       CachedRenderingData cached_rendering_data;
       float preferred_x_pos;
       uint8_t pressed;
       SharedVector<UndoItem> undo_items;
       SharedVector<UndoItem> redo_items;
   };
   
   struct SwipeGestureHandler {
       Property<bool> enabled;
       Property<bool> handle_swipe_left;
       Property<bool> handle_swipe_right;
       Property<bool> handle_swipe_up;
       Property<bool> handle_swipe_down;
       private_api::CallbackHelper<void> moved;
       private_api::CallbackHelper<void> swiped;
       private_api::CallbackHelper<void> cancelled;
       Property<LogicalPosition> pressed_position;
       Property<LogicalPosition> current_position;
       Property<bool> swiping;
       bool pressed;
       CachedRenderingData cached_rendering_data;
   };
   
   struct Padding {
       float begin;
       float end;
   };
   
   struct GridLayoutCellData {
       uint16_t col_or_row;
       uint16_t span;
       LayoutInfo constraint;
   };
   
   struct GridLayoutData {
       float size;
       float spacing;
       Padding padding;
       Slice<GridLayoutCellData> cells;
   };
   
   struct BoxLayoutCellData {
       LayoutInfo constraint;
   };
   
   struct BoxLayoutData {
       float size;
       float spacing;
       Padding padding;
       LayoutAlignment alignment;
       Slice<BoxLayoutCellData> cells;
   };
   
   struct EasingCurve {
       enum class Tag : uint32_t {
           Linear,
           CubicBezier,
           EaseInElastic,
           EaseOutElastic,
           EaseInOutElastic,
           EaseInBounce,
           EaseOutBounce,
           EaseInOutBounce,
       };
   
       struct CubicBezier_Body {
           float _0[4];
       };
   
       Tag tag;
       union {
           CubicBezier_Body cubic_bezier;
       };
       constexpr EasingCurve(EasingCurve::Tag tag = Tag::Linear, float a = 0, float b = 0, float c = 1, float d = 1) : tag(tag), cubic_bezier{{a,b,c,d}} {}
   };
   
   struct PropertyAnimation {
       int32_t delay;
       int32_t duration;
       float iteration_count;
       AnimationDirection direction;
       EasingCurve easing;
   };
   
   using IntSize = Size2D<uint32_t>;
   
   using Size = Size2D<float>;
   
   union WindowEvent {
       enum class Tag : uint32_t {
           PointerPressed,
           PointerReleased,
           PointerMoved,
           PointerScrolled,
           PointerExited,
           KeyPressed,
           KeyPressRepeated,
           KeyReleased,
           ScaleFactorChanged,
           Resized,
           CloseRequested,
           WindowActiveChanged,
       };
   
       struct PointerPressed_Body {
           Tag tag;
           LogicalPosition position;
           PointerEventButton button;
       };
   
       struct PointerReleased_Body {
           Tag tag;
           LogicalPosition position;
           PointerEventButton button;
       };
   
       struct PointerMoved_Body {
           Tag tag;
           LogicalPosition position;
       };
   
       struct PointerScrolled_Body {
           Tag tag;
           LogicalPosition position;
           float delta_x;
           float delta_y;
       };
   
       struct KeyPressed_Body {
           Tag tag;
           SharedString text;
       };
   
       struct KeyPressRepeated_Body {
           Tag tag;
           SharedString text;
       };
   
       struct KeyReleased_Body {
           Tag tag;
           SharedString text;
       };
   
       struct ScaleFactorChanged_Body {
           Tag tag;
           float scale_factor;
       };
   
       struct Resized_Body {
           Tag tag;
           LogicalSize size;
       };
   
       struct WindowActiveChanged_Body {
           Tag tag;
           bool _0;
       };
   
       struct {
           Tag tag;
       };
       PointerPressed_Body pointer_pressed;
       PointerReleased_Body pointer_released;
       PointerMoved_Body pointer_moved;
       PointerScrolled_Body pointer_scrolled;
       KeyPressed_Body key_pressed;
       KeyPressRepeated_Body key_press_repeated;
       KeyReleased_Body key_released;
       ScaleFactorChanged_Body scale_factor_changed;
       Resized_Body resized;
       WindowActiveChanged_Body window_active_changed;
   /* Some members of the WindowEvent enum have destructors (with SharedString), but thankfully we don't use these so we can have an empty constructor */
       ~WindowEvent() {}
   };
   
   struct Rect {
       float x;
       float y;
       float width;
       float height;
   };
   
   struct CharacterMapEntry {
       uint32_t code_point;
       uint16_t glyph_index;
   };
   
   struct BitmapGlyph {
       int16_t x;
       int16_t y;
       int16_t width;
       int16_t height;
       int16_t x_advance;
       Slice<uint8_t> data;
   };
   
   struct BitmapGlyphs {
       int16_t pixel_size;
       Slice<BitmapGlyph> glyph_data;
   };
   
   struct BitmapFont {
       Slice<uint8_t> family_name;
       Slice<CharacterMapEntry> character_map;
       float units_per_em;
       float ascent;
       float descent;
       float x_height;
       float cap_height;
       Slice<BitmapGlyphs> glyphs;
       uint16_t weight;
       bool italic;
       bool sdf;
   };
   
   template<typename T, typename U>
   struct Box2D {
       Point2D<T> min;
       Point2D<T> max;
   };
   
   struct PhysicalRegion {
       Box2D<int16_t, PhysicalPx> rectangles[PHYSICAL_REGION_MAX_SIZE];
       uintptr_t count;
   };
   
   struct Empty {
       CachedRenderingData cached_rendering_data;
   };
   
   struct Rectangle {
       Property<Brush> background;
       CachedRenderingData cached_rendering_data;
   };
   
   struct BasicBorderRectangle {
       Property<Brush> background;
       Property<LogicalLength> border_width;
       Property<LogicalLength> border_radius;
       Property<Brush> border_color;
       CachedRenderingData cached_rendering_data;
   };
   
   struct BorderRectangle {
       Property<Brush> background;
       Property<LogicalLength> border_width;
       Property<LogicalLength> border_radius;
       Property<LogicalLength> border_top_left_radius;
       Property<LogicalLength> border_top_right_radius;
       Property<LogicalLength> border_bottom_left_radius;
       Property<LogicalLength> border_bottom_right_radius;
       Property<Brush> border_color;
       CachedRenderingData cached_rendering_data;
   };
   
   struct ImageItem {
       Property<Image> source;
       Property<LogicalLength> width;
       Property<LogicalLength> height;
       Property<ImageFit> image_fit;
       Property<ImageRendering> image_rendering;
       Property<Brush> colorize;
       CachedRenderingData cached_rendering_data;
   };
   
   struct ClippedImage {
       Property<Image> source;
       Property<LogicalLength> width;
       Property<LogicalLength> height;
       Property<ImageFit> image_fit;
       Property<ImageRendering> image_rendering;
       Property<Brush> colorize;
       Property<int32_t> source_clip_x;
       Property<int32_t> source_clip_y;
       Property<int32_t> source_clip_width;
       Property<int32_t> source_clip_height;
       Property<ImageHorizontalAlignment> horizontal_alignment;
       Property<ImageVerticalAlignment> vertical_alignment;
       Property<ImageTiling> horizontal_tiling;
       Property<ImageTiling> vertical_tiling;
       CachedRenderingData cached_rendering_data;
   };
   
   struct TouchArea {
       Property<bool> enabled;
       Property<bool> pressed;
       Property<bool> has_hover;
       Property<LogicalLength> pressed_x;
       Property<LogicalLength> pressed_y;
       Property<LogicalLength> mouse_x;
       Property<LogicalLength> mouse_y;
       Property<MouseCursor> mouse_cursor;
       private_api::CallbackHelper<void> clicked;
       private_api::CallbackHelper<void> double_clicked;
       private_api::CallbackHelper<void> moved;
       private_api::CallbackHelper<PointerEvent> pointer_event;
       private_api::CallbackHelper<PointerScrollEvent, EventResult> scroll_event;
       CachedRenderingData cached_rendering_data;
       bool grabbed;
   };
   
   struct FocusScope {
       Property<bool> enabled;
       Property<bool> has_focus;
       private_api::CallbackHelper<KeyEvent, EventResult> key_pressed;
       private_api::CallbackHelper<KeyEvent, EventResult> key_released;
       private_api::CallbackHelper<void> focus_changed_event;
       CachedRenderingData cached_rendering_data;
   };
   
   struct Flickable {
       Property<LogicalLength> viewport_x;
       Property<LogicalLength> viewport_y;
       Property<LogicalLength> viewport_width;
       Property<LogicalLength> viewport_height;
       Property<bool> interactive;
       private_api::CallbackHelper<void> flicked;
       FlickableDataBox data;
       CachedRenderingData cached_rendering_data;
       inline Flickable(); inline ~Flickable();
   };
   
   struct SimpleText {
       Property<LogicalLength> width;
       Property<LogicalLength> height;
       Property<SharedString> text;
       Property<LogicalLength> font_size;
       Property<int32_t> font_weight;
       Property<Brush> color;
       Property<TextHorizontalAlignment> horizontal_alignment;
       Property<TextVerticalAlignment> vertical_alignment;
       CachedRenderingData cached_rendering_data;
   };
   
   struct ComplexText {
       Property<LogicalLength> width;
       Property<LogicalLength> height;
       Property<SharedString> text;
       Property<LogicalLength> font_size;
       Property<int32_t> font_weight;
       Property<Brush> color;
       Property<TextHorizontalAlignment> horizontal_alignment;
       Property<TextVerticalAlignment> vertical_alignment;
       Property<SharedString> font_family;
       Property<bool> font_italic;
       Property<TextWrap> wrap;
       Property<TextOverflow> overflow;
       Property<LogicalLength> letter_spacing;
       Property<Brush> stroke;
       Property<LogicalLength> stroke_width;
       Property<TextStrokeStyle> stroke_style;
       CachedRenderingData cached_rendering_data;
   };
   
   struct Path {
       Property<PathData> elements;
       Property<Brush> fill;
       Property<FillRule> fill_rule;
       Property<Brush> stroke;
       Property<LogicalLength> stroke_width;
       Property<float> viewbox_x;
       Property<float> viewbox_y;
       Property<float> viewbox_width;
       Property<float> viewbox_height;
       Property<bool> clip;
       CachedRenderingData cached_rendering_data;
   };
   
   struct WindowItem {
       Property<LogicalLength> width;
       Property<LogicalLength> height;
       Property<Brush> background;
       Property<SharedString> title;
       Property<bool> no_frame;
       Property<bool> skip_taskbar;
       Property<LogicalLength> resize_border_width;
       Property<bool> always_on_top;
       Property<Image> icon;
       Property<SharedString> default_font_family;
       Property<LogicalLength> default_font_size;
       Property<int32_t> default_font_weight;
       CachedRenderingData cached_rendering_data;
   };
   
   struct Clip {
       Property<LogicalLength> border_top_left_radius;
       Property<LogicalLength> border_top_right_radius;
       Property<LogicalLength> border_bottom_left_radius;
       Property<LogicalLength> border_bottom_right_radius;
       Property<LogicalLength> border_width;
       CachedRenderingData cached_rendering_data;
       Property<bool> clip;
   };
   
   struct BoxShadow {
       Property<LogicalLength> border_radius;
       Property<LogicalLength> offset_x;
       Property<LogicalLength> offset_y;
       Property<Color> color;
       Property<LogicalLength> blur;
       CachedRenderingData cached_rendering_data;
   };
   
   struct Rotate {
       Property<float> rotation_angle;
       Property<LogicalLength> rotation_origin_x;
       Property<LogicalLength> rotation_origin_y;
       CachedRenderingData cached_rendering_data;
   };
   
   struct Opacity {
       Property<float> opacity;
       CachedRenderingData cached_rendering_data;
   };
   
   struct Layer {
       Property<bool> cache_rendering_hint;
       CachedRenderingData cached_rendering_data;
   };
   
   struct ContextMenu {
       private_api::CallbackHelper<MenuEntry, std::shared_ptr<slint::Model<MenuEntry>>> sub_menu;
       private_api::CallbackHelper<MenuEntry> activated;
       CachedRenderingData cached_rendering_data;
   };
   
   extern "C" {
   
   void slint_callback_init(CallbackOpaque *out);
   
   void slint_callback_call(const CallbackOpaque *sig, const void *arg, void *ret);
   
   void slint_callback_set_handler(const CallbackOpaque *sig,
                                   void (*binding)(void *user_data, const void *arg, void *ret),
                                   void *user_data,
                                   void (*drop_user_data)(void*));
   
   void slint_callback_drop(CallbackOpaque *handle);
   
   bool slint_date_time_use_24_hour_format();
   
   int32_t slint_date_time_month_day_count(uint32_t month, int32_t year);
   
   int32_t slint_date_time_month_offset(uint32_t month, int32_t year);
   
   void slint_date_time_format_date(const SharedString *format,
                                    uint32_t day,
                                    uint32_t month,
                                    int32_t year,
                                    SharedString *out);
   
   void slint_date_time_date_now(int32_t *d, int32_t *m, int32_t *y);
   
   bool slint_date_time_parse_date(const SharedString *date,
                                   const SharedString *format,
                                   int32_t *d,
                                   int32_t *m,
                                   int32_t *y);
   
   void slint_register_item_tree(const ItemTreeRc *item_tree_rc,
                                 const WindowAdapterRcOpaque *window_handle);
   
   void slint_unregister_item_tree(ItemTreeRefPin component,
                                   Slice<VOffset<uint8_t, ItemVTable, AllowPin>> item_array,
                                   const WindowAdapterRcOpaque *window_handle);
   
   VisitChildrenResult slint_visit_item_tree(const ItemTreeRc *item_tree,
                                             Slice<ItemTreeNode> item_tree_array,
                                             intptr_t index,
                                             TraversalOrder order,
                                             VRefMut<ItemVisitorVTable> visitor,
                                             VisitChildrenResult (*visit_dynamic)(const void *base,
                                                                                  TraversalOrder order,
                                                                                  VRefMut<ItemVisitorVTable> visitor,
                                                                                  uint32_t dyn_index));
   
   LogicalPoint slint_item_absolute_position(const VRc<ItemTreeVTable> *self_component,
                                             uint32_t self_index);
   
   void slint_flickable_data_init(FlickableDataBox *data);
   
   void slint_flickable_data_free(FlickableDataBox *data);
   
   void slint_textinput_set_selection_offsets(Pin<const TextInput*> text_input,
                                              const WindowAdapterRcOpaque *window_adapter,
                                              const VRc<ItemTreeVTable> *self_component,
                                              uint32_t self_index,
                                              int32_t start,
                                              int32_t end);
   
   void slint_textinput_select_all(Pin<const TextInput*> text_input,
                                   const WindowAdapterRcOpaque *window_adapter,
                                   const VRc<ItemTreeVTable> *self_component,
                                   uint32_t self_index);
   
   void slint_textinput_clear_selection(Pin<const TextInput*> text_input,
                                        const WindowAdapterRcOpaque *window_adapter,
                                        const VRc<ItemTreeVTable> *self_component,
                                        uint32_t self_index);
   
   void slint_textinput_cut(Pin<const TextInput*> text_input,
                            const WindowAdapterRcOpaque *window_adapter,
                            const VRc<ItemTreeVTable> *self_component,
                            uint32_t self_index);
   
   void slint_textinput_copy(Pin<const TextInput*> text_input,
                             const WindowAdapterRcOpaque *window_adapter,
                             const VRc<ItemTreeVTable> *self_component,
                             uint32_t self_index);
   
   void slint_textinput_paste(Pin<const TextInput*> text_input,
                              const WindowAdapterRcOpaque *window_adapter,
                              const VRc<ItemTreeVTable> *self_component,
                              uint32_t self_index);
   
   FontMetrics slint_cpp_text_item_fontmetrics(const WindowAdapterRcOpaque *window_adapter,
                                               const VRc<ItemTreeVTable> *self_component,
                                               uint32_t self_index);
   
   void slint_swipegesturehandler_cancel(Pin<const SwipeGestureHandler*> s,
                                         const WindowAdapterRcOpaque *window_adapter,
                                         const VRc<ItemTreeVTable> *self_component,
                                         uint32_t self_index);
   
   void slint_solve_grid_layout(const GridLayoutData *data, SharedVector<float> *result);
   
   LayoutInfo slint_grid_layout_info(Slice<GridLayoutCellData> cells,
                                     float spacing,
                                     const Padding *padding);
   
   void slint_solve_box_layout(const BoxLayoutData *data,
                               Slice<uint32_t> repeater_indexes,
                               SharedVector<float> *result);
   
   LayoutInfo slint_box_layout_info(Slice<BoxLayoutCellData> cells,
                                    float spacing,
                                    const Padding *padding,
                                    LayoutAlignment alignment);
   
   LayoutInfo slint_box_layout_info_ortho(Slice<BoxLayoutCellData> cells, const Padding *padding);
   
   void slint_reorder_dialog_button_layout(GridLayoutCellData *cells, Slice<DialogButtonRole> roles);
   
   void slint_property_init(PropertyHandleOpaque *out);
   
   void slint_property_update(const PropertyHandleOpaque *handle, void *val);
   
   void slint_property_set_changed(const PropertyHandleOpaque *handle, const void *value);
   
   void slint_property_set_binding(const PropertyHandleOpaque *handle,
                                   void (*binding)(void *user_data, void *pointer_to_value),
                                   void *user_data,
                                   void (*drop_user_data)(void*),
                                   bool (*intercept_set)(void *user_data, const void *pointer_to_Value),
                                   bool (*intercept_set_binding)(void *user_data, void *new_binding));
   
   void slint_property_set_binding_internal(const PropertyHandleOpaque *handle, void *binding);
   
   bool slint_property_is_dirty(const PropertyHandleOpaque *handle);
   
   void slint_property_mark_dirty(const PropertyHandleOpaque *handle);
   
   void slint_property_drop(PropertyHandleOpaque *handle);
   
   void slint_property_set_animated_value_int(const PropertyHandleOpaque *handle,
                                              int32_t from,
                                              int32_t to,
                                              const PropertyAnimation *animation_data);
   
   void slint_property_set_animated_value_float(const PropertyHandleOpaque *handle,
                                                float from,
                                                float to,
                                                const PropertyAnimation *animation_data);
   
   void slint_property_set_animated_value_color(const PropertyHandleOpaque *handle,
                                                Color from,
                                                Color to,
                                                const PropertyAnimation *animation_data);
   
   void slint_property_set_animated_value_brush(const PropertyHandleOpaque *handle,
                                                const Brush *from,
                                                const Brush *to,
                                                const PropertyAnimation *animation_data);
   
   void slint_property_set_animated_binding_int(const PropertyHandleOpaque *handle,
                                                void (*binding)(void*, int*),
                                                void *user_data,
                                                void (*drop_user_data)(void*),
                                                const PropertyAnimation *animation_data,
                                                PropertyAnimation (*transition_data)(void *user_data,
                                                                                     uint64_t *start_instant));
   
   void slint_property_set_animated_binding_float(const PropertyHandleOpaque *handle,
                                                  void (*binding)(void*, float*),
                                                  void *user_data,
                                                  void (*drop_user_data)(void*),
                                                  const PropertyAnimation *animation_data,
                                                  PropertyAnimation (*transition_data)(void *user_data,
                                                                                       uint64_t *start_instant));
   
   void slint_property_set_animated_binding_color(const PropertyHandleOpaque *handle,
                                                  void (*binding)(void*, Color*),
                                                  void *user_data,
                                                  void (*drop_user_data)(void*),
                                                  const PropertyAnimation *animation_data,
                                                  PropertyAnimation (*transition_data)(void *user_data,
                                                                                       uint64_t *start_instant));
   
   void slint_property_set_animated_binding_brush(const PropertyHandleOpaque *handle,
                                                  void (*binding)(void*, Brush*),
                                                  void *user_data,
                                                  void (*drop_user_data)(void*),
                                                  const PropertyAnimation *animation_data,
                                                  PropertyAnimation (*transition_data)(void *user_data,
                                                                                       uint64_t *start_instant));
   
   void slint_property_set_state_binding(const PropertyHandleOpaque *handle,
                                         int32_t (*binding)(void*),
                                         void *user_data,
                                         void (*drop_user_data)(void*));
   
   void slint_property_tracker_init(PropertyTrackerOpaque *out);
   
   void slint_property_tracker_evaluate(const PropertyTrackerOpaque *handle,
                                        void (*callback)(void *user_data),
                                        void *user_data);
   
   void slint_property_tracker_evaluate_as_dependency_root(const PropertyTrackerOpaque *handle,
                                                           void (*callback)(void *user_data),
                                                           void *user_data);
   
   bool slint_property_tracker_is_dirty(const PropertyTrackerOpaque *handle);
   
   void slint_property_tracker_drop(PropertyTrackerOpaque *handle);
   
   void slint_change_tracker_construct(ChangeTracker *ct);
   
   void slint_change_tracker_drop(ChangeTracker *ct);
   
   void slint_change_tracker_init(const ChangeTracker *ct,
                                  void *user_data,
                                  void (*drop_user_data)(void *user_data),
                                  bool (*eval_fn)(void *user_data),
                                  void (*notify_fn)(void *user_data));
   
   uint64_t slint_animation_tick();
   
   uint8_t *slint_shared_vector_allocate(uintptr_t size,
                                         uintptr_t align);
   
   void slint_shared_vector_free(uint8_t *ptr,
                                 uintptr_t size,
                                 uintptr_t align);
   
   const uint8_t *slint_shared_vector_empty();
   
   const char *slint_shared_string_bytes(const SharedString *ss);
   
   void slint_shared_string_drop(const SharedString *ss);
   
   void slint_shared_string_clone(SharedString *out, const SharedString *ss);
   
   void slint_shared_string_from_bytes(SharedString *out, const char *bytes, uintptr_t len);
   
   void slint_shared_string_from_number(SharedString *out, double n);
   
   void slint_shared_string_append(SharedString *self_, const char *bytes, uintptr_t len);
   
   void slint_shared_string_to_lowercase(SharedString *out, const SharedString *ss);
   
   void slint_shared_string_to_uppercase(SharedString *out, const SharedString *ss);
   
   void slint_mock_elapsed_time(uint64_t time_in_ms);
   
   uint64_t slint_get_mocked_time();
   
   void slint_send_mouse_click(float x, float y, const WindowAdapterRc *window_adapter);
   
   void slint_send_keyboard_char(const SharedString *string,
                                 bool pressed,
                                 const WindowAdapterRc *window_adapter);
   
   void send_keyboard_string_sequence(const SharedString *sequence,
                                      const WindowAdapterRc *window_adapter);
   
   uint64_t slint_timer_interval(uintptr_t id);
   
   void slint_translate(SharedString *to_translate,
                        const SharedString *context,
                        const SharedString *domain,
                        Slice<SharedString> arguments,
                        int32_t n,
                        const SharedString *plural);
   
   void slint_translations_mark_dirty();
   
   void slint_translate_from_bundle(Slice<const char*> strs,
                                    Slice<SharedString> arguments,
                                    SharedString *output);
   
   void slint_translate_from_bundle_with_plural(Slice<const char*> strs,
                                                Slice<uint32_t> indices,
                                                Slice<uintptr_t(*)(int32_t)> plural_rules,
                                                Slice<SharedString> arguments,
                                                int32_t n,
                                                SharedString *output);
   
   void slint_translate_set_bundled_languages(Slice<Slice<uint8_t>> languages);
   
   bool slint_translate_select_bundled_translation(Slice<uint8_t> locale);
   
   void slint_windowrc_drop(WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_clone(const WindowAdapterRcOpaque *source, WindowAdapterRcOpaque *target);
   
   void slint_windowrc_show(const WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_hide(const WindowAdapterRcOpaque *handle);
   
   bool slint_windowrc_is_visible(const WindowAdapterRcOpaque *handle);
   
   float slint_windowrc_get_scale_factor(const WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_set_scale_factor(const WindowAdapterRcOpaque *handle, float value);
   
   bool slint_windowrc_get_text_input_focused(const WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_set_text_input_focused(const WindowAdapterRcOpaque *handle, bool value);
   
   void slint_windowrc_set_focus_item(const WindowAdapterRcOpaque *handle,
                                      const ItemRc *focus_item,
                                      bool set_focus);
   
   void slint_windowrc_set_component(const WindowAdapterRcOpaque *handle, const ItemTreeRc *component);
   
   uint32_t slint_windowrc_show_popup(const WindowAdapterRcOpaque *handle,
                                      const ItemTreeRc *popup,
                                      LogicalPosition position,
                                      PopupClosePolicy close_policy,
                                      const ItemRc *parent_item);
   
   void slint_windowrc_close_popup(const WindowAdapterRcOpaque *handle, uint32_t popup_id);
   
   bool slint_windowrc_set_rendering_notifier(const WindowAdapterRcOpaque *handle,
                                              void (*callback)(RenderingState rendering_state,
                                                               GraphicsAPI graphics_api,
                                                               void *user_data),
                                              void (*drop_user_data)(void *user_data),
                                              void *user_data,
                                              SetRenderingNotifierError *error);
   
   void slint_windowrc_on_close_requested(const WindowAdapterRcOpaque *handle,
                                          CloseRequestResponse (*callback)(void *user_data),
                                          void (*drop_user_data)(void *user_data),
                                          void *user_data);
   
   void slint_windowrc_request_redraw(const WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_position(const WindowAdapterRcOpaque *handle, Point2D<int32_t> *pos);
   
   void slint_windowrc_set_physical_position(const WindowAdapterRcOpaque *handle,
                                             const Point2D<int32_t> *pos);
   
   void slint_windowrc_set_logical_position(const WindowAdapterRcOpaque *handle,
                                            const Point2D<float> *pos);
   
   IntSize slint_windowrc_size(const WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_set_physical_size(const WindowAdapterRcOpaque *handle, const IntSize *size);
   
   void slint_windowrc_set_logical_size(const WindowAdapterRcOpaque *handle, const Size *size);
   
   ColorScheme slint_windowrc_color_scheme(const WindowAdapterRcOpaque *handle);
   
   float slint_windowrc_default_font_size(const WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_dispatch_key_event(const WindowAdapterRcOpaque *handle,
                                          KeyEventType event_type,
                                          const SharedString *text,
                                          bool repeat);
   
   void slint_windowrc_dispatch_pointer_event(const WindowAdapterRcOpaque *handle, MouseEvent event);
   
   void slint_windowrc_dispatch_event(const WindowAdapterRcOpaque *handle, const WindowEvent *event);
   
   bool slint_windowrc_is_fullscreen(const WindowAdapterRcOpaque *handle);
   
   bool slint_windowrc_is_minimized(const WindowAdapterRcOpaque *handle);
   
   bool slint_windowrc_is_maximized(const WindowAdapterRcOpaque *handle);
   
   void slint_windowrc_set_fullscreen(const WindowAdapterRcOpaque *handle, bool value);
   
   void slint_windowrc_set_minimized(const WindowAdapterRcOpaque *handle, bool value);
   
   void slint_windowrc_set_maximized(const WindowAdapterRcOpaque *handle, bool value);
   
   bool slint_windowrc_take_snapshot(const WindowAdapterRcOpaque *handle,
                                     SharedVector<Rgba8Pixel> *data,
                                     uint32_t *width,
                                     uint32_t *height);
   
   } // extern "C"
   
   } // namespace cbindgen_private
   } // namespace slint
   
   
   namespace slint::private_api {
   #define SLINT_DECL_ITEM(ItemName) \
       extern const cbindgen_private::ItemVTable ItemName##VTable; \
       extern SLINT_DLL_IMPORT const cbindgen_private::ItemVTable* slint_get_##ItemName##VTable();
   
   extern "C" {
   SLINT_DECL_ITEM(Empty);
   SLINT_DECL_ITEM(Rectangle);
   SLINT_DECL_ITEM(BasicBorderRectangle);
   SLINT_DECL_ITEM(BorderRectangle);
   SLINT_DECL_ITEM(ImageItem);
   SLINT_DECL_ITEM(ClippedImage);
   SLINT_DECL_ITEM(TouchArea);
   SLINT_DECL_ITEM(FocusScope);
   SLINT_DECL_ITEM(SwipeGestureHandler);
   SLINT_DECL_ITEM(Flickable);
   SLINT_DECL_ITEM(SimpleText);
   SLINT_DECL_ITEM(ComplexText);
   SLINT_DECL_ITEM(Path);
   SLINT_DECL_ITEM(WindowItem);
   SLINT_DECL_ITEM(TextInput);
   SLINT_DECL_ITEM(Clip);
   SLINT_DECL_ITEM(BoxShadow);
   SLINT_DECL_ITEM(Rotate);
   SLINT_DECL_ITEM(Opacity);
   SLINT_DECL_ITEM(Layer);
   SLINT_DECL_ITEM(ContextMenu);
   }
   
   #undef SLINT_DECL_ITEM
   }
