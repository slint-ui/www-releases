<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Build a set of expressions used as indices, to cache in temporary variables when emitted."><title>find_checked_indexes in slint::wgpu_24::wgpu::core::naga::proc::index - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../" data-static-root-path="../../../../../../../static.files/" data-current-crate="slint" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0-nightly (f26e58023 2025-06-30)" data-channel="nightly" data-search-js="search-179e01a3.js" data-settings-js="settings-5514c975.js" ><script src="../../../../../../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../../../../static.files/main-340f468f.js"></script><noscript><link rel="stylesheet" href="../../../../../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../static.files/favicon-044be391.svg"><!--
    This file is used to add syntax highlighting of the `.slint` snippets in the generated rustdoc, sphinx and mdbook documentation.
    It can be injected via the `--html-in-header slint-docs-highlight.html` option of rustdoc, is included via _templates/layout.html
    in sphinx and via head.hbs in mdbook.
-->
<link rel="stylesheet" href="https://slint.dev/resources/highlightjs/11.0.1/default.min.css">
<script src="https://slint.dev/resources/highlightjs/11.0.1/highlight.min.js"></script>
<script>
  function highlight_slint(hljs) {
    const KEYWORDS = {
      keyword:
        "animate callback changed component enum export for function global if import in in-out inherits out parent private property public pure root self states struct",
      literal: "false true",
      built_in:
        "ArcTo Clip Close Colors CubicTo Flickable FocusScope GridLayout HorizontalLayout Image LineTo Math MoveTo Path PopupWindow QuadraticTo Rectangle Row Text TextInput TouchArea VerticalLayout Window animation-tick debug",
      type: "bool duration easing float int length logical-length relative-font-size string",
    };

    return {
      name: 'slint',
      case_insensitive: false,
      keywords: KEYWORDS,
      contains: [
        hljs.QUOTE_STRING_MODE,
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.COMMENT('/\\*', '\\*/', {
          contains: ['self']
        }),
        {
          className: 'number',
          begin: '\\b\\d+(\\.\\d+)?(\\w+)?',
          relevance: 0
        },
        {
          className: 'title',
          begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]* *:=',
        },
        {
          className: 'symbol',
          begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]*(:| *=>)',
        },
        {
          className: 'built_in',
          begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]*!',
        },
      ],
      illegal: /@/
    };
  };

  // Tags used in fenced code blocks
  for (let tag of ["slint", "slint,no-preview", "slint,no-auto-preview", "slint,ignore"]) {
    hljs.registerLanguage(tag, highlight_slint);
  }


  window.addEventListener("DOMContentLoaded", () => {
    const rustDoc = document.querySelector('meta[name="generator"]')?.content == "rustdoc";
    if (rustDoc) {
      // Only highlight .slint blocks, leave the others to rustdoc
      for (slintBlock of document.querySelectorAll("[class*=language-slint]")) {
        hljs.highlightElement(slintBlock)
      }

      // Some of the rustdoc selectors require the pre element to have the rust class
      for (codeBlock of document.querySelectorAll(".language-slint.hljs")) {
        codeBlock.classList.add("rust");
        codeBlock.classList.remove("hljs");
      }

      // Change the hljs generated classes to the rustdoc
      // ones, so that the highlighting adjusts to the theme correctly.
      const highlightJSToRustDoc = [
        ["comment", "comment"],
        ["number", "number"],
        ["symbol", "struct"], // width:
        ["keyword", "kw"],
        ["built_in", "primitive"],
        ["string", "string"],
        ["title", "fnname"], // Foo :=
        ["type", "type"]
      ];

      for ([hljs_class, rustdoc_class] of highlightJSToRustDoc) {
        for (titleElement of document.querySelectorAll(`.hljs-${hljs_class}`)) {
          titleElement.classList.remove(`hljs-${hljs_class}`);
          titleElement.classList.add(rustdoc_class);
        }
      }
    } else {
      // For use with the mdbook Tutorial
      hljs.highlightAll();

      // The Sphinx/my_st generated HTML for code blocks doesn't use <code> tags, so highlight.js'
      // default selector "pre code" doesn't match. Let's do it by hand:
      for (block of document.querySelectorAll("div[class*=highlight-slint] div.highlight pre")) {
        hljs.highlightElement(block)
      }
    }

    // Fix up links that sphinx handles but for rustdoc we need to resolve manually:
    {
      let target_url = null;
      if (document.location.hostname == "snapshots.slint.dev") {
        target_url = `https://snapshots.slint.dev/master/docs/slint/`;
      } else {
        let version = document.querySelector("span.version");
        if (version !== null) {
          target_url = `https://slint.dev/releases/${version.innerText}/docs/slint/`;
        }
      }

      if (target_url !== null) {
        for (let link of document.querySelectorAll("a[href^='slint-reference:']")) {
          link.href = link.href.replace("slint-reference:", target_url);
        }
      }
    }
  });
</script>

</head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../../../../../slint/index.html"><img src="https://slint.dev/logo/slint-logo-square-light.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../../../../../slint/index.html"><img src="https://slint.dev/logo/slint-logo-square-light.svg" alt="logo"></a><h2><a href="../../../../../../../slint/index.html">slint</a><span class="version">1.13.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In slint::<wbr>wgpu_<wbr>24::<wbr>wgpu::<wbr>core::<wbr>naga::<wbr>proc::<wbr>index</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../../../../index.html">slint</a>::<wbr><a href="../../../../../index.html">wgpu_24</a>::<wbr><a href="../../../../index.html">wgpu</a>::<wbr><a href="../../../index.html">core</a>::<wbr><a href="../../index.html">naga</a>::<wbr><a href="../index.html">proc</a>::<wbr><a href="index.html">index</a></div><h1>Function <span class="fn">find_checked_indexes</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub fn find_checked_indexes(
    module: &amp;<a class="struct" href="../../struct.Module.html" title="struct slint::wgpu_24::wgpu::core::naga::Module">Module</a>,
    function: &amp;<a class="struct" href="../../struct.Function.html" title="struct slint::wgpu_24::wgpu::core::naga::Function">Function</a>,
    info: &amp;<a class="struct" href="../../valid/struct.FunctionInfo.html" title="struct slint::wgpu_24::wgpu::core::naga::valid::FunctionInfo">FunctionInfo</a>,
    policies: <a class="struct" href="../struct.BoundsCheckPolicies.html" title="struct slint::wgpu_24::wgpu::core::naga::proc::BoundsCheckPolicies">BoundsCheckPolicies</a>,
) -&gt; HandleSet&lt;<a class="enum" href="../../enum.Expression.html" title="enum slint::wgpu_24::wgpu::core::naga::Expression">Expression</a>&gt;</code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unstable-wgpu-24</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Build a set of expressions used as indices, to cache in temporary variables when
emitted.</p>
<p>Given the bounds-check policies <code>policies</code>, construct a <code>HandleSet</code> containing the handle
indices of all the expressions in <code>function</code> that are ever used as guarded indices
under the <a href="../enum.BoundsCheckPolicy.html#variant.ReadZeroSkipWrite" title="variant slint::wgpu_24::wgpu::core::naga::proc::BoundsCheckPolicy::ReadZeroSkipWrite"><code>ReadZeroSkipWrite</code></a> policy. The <code>module</code> argument must be the module to
which <code>function</code> belongs, and <code>info</code> should be that function’s analysis results.</p>
<p>Such index expressions will be used twice in the generated code: first for the
comparison to see if the index is in bounds, and then for the access itself, should
the comparison succeed. To avoid computing the expressions twice, the generated code
should cache them in temporary variables.</p>
<p>Why do we need to build such a set in advance, instead of just processing access
expressions as we encounter them? Whether an expression needs to be cached depends on
whether it appears as something like the <a href="../../enum.Expression.html#variant.Access.field.index" title="field slint::wgpu_24::wgpu::core::naga::Expression::index"><code>index</code></a> operand of an <a href="../../enum.Expression.html#variant.Access" title="variant slint::wgpu_24::wgpu::core::naga::Expression::Access"><code>Access</code></a> expression
or the <a href="../../enum.Expression.html#variant.ImageLoad.field.level" title="field slint::wgpu_24::wgpu::core::naga::Expression::level"><code>level</code></a> operand of an <a href="../../enum.Expression.html#variant.ImageLoad" title="variant slint::wgpu_24::wgpu::core::naga::Expression::ImageLoad"><code>ImageLoad</code></a> expression, and on the index bounds check
policies that apply to those accesses. But <a href="../../enum.Statement.html#variant.Emit" title="variant slint::wgpu_24::wgpu::core::naga::Statement::Emit"><code>Emit</code></a> statements just identify a range
of expressions by index; there’s no good way to tell what an expression is used
for. The only way to do it is to just iterate over all the expressions looking for
relevant <code>Access</code> expressions — which is what this function does.</p>
<p>Simple expressions like variable loads and constants don’t make sense to cache: it’s
no better than just re-evaluating them. But constants are not covered by <code>Emit</code>
statements, and <code>Load</code>s are always cached to ensure they occur at the right time, so
we don’t bother filtering them out from this set.</p>
<p>Fortunately, we don’t need to deal with <a href="../../enum.Statement.html#variant.ImageStore" title="variant slint::wgpu_24::wgpu::core::naga::Statement::ImageStore"><code>ImageStore</code></a> statements here. When we emit
code for a statement, the writer isn’t in the middle of an expression, so we can just
emit declarations for temporaries, initialized appropriately.</p>
<p>None of these concerns apply for SPIR-V output, since it’s easy to just reuse an
instruction ID in two places; that has the same semantics as a temporary variable, and
it’s inherent in the design of SPIR-V. This function is more useful for text-based
back ends.</p>
</div></details></section></div></main></body></html>