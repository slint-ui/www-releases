<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="NOTE: This library is an internal crate of the Slint project. This crate should not be used directly by applications using Slint. You should use the `slint` crate instead."><title>i_slint_backend_testing - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-c233d2bd.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="i_slint_backend_testing" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0-nightly (df35ff6c3 2025-04-23)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"><!--
    This file is used to add syntax highlighting of the `.slint` snippets in the generated rustdoc, sphinx and mdbook documentation.
    It can be injected via the `--html-in-header slint-docs-highlight.html` option of rustdoc, is included via _templates/layout.html
    in sphinx and via head.hbs in mdbook.
-->
<link rel="stylesheet" href="https://slint.dev/resources/highlightjs/11.0.1/default.min.css">
<script src="https://slint.dev/resources/highlightjs/11.0.1/highlight.min.js"></script>
<script>
  function highlight_slint(hljs) {
    const KEYWORDS = {
      keyword:
        "animate callback changed component enum export for function global if import in in-out inherits out parent private property public pure root self states struct",
      literal: "false true",
      built_in:
        "ArcTo Clip Close Colors CubicTo Flickable FocusScope GridLayout HorizontalLayout Image LineTo Math MoveTo Path PopupWindow QuadraticTo Rectangle Row Text TextInput TouchArea VerticalLayout Window animation-tick debug",
      type: "bool duration easing float int length logical-length relative-font-size string",
    };

    return {
      name: 'slint',
      case_insensitive: false,
      keywords: KEYWORDS,
      contains: [
        hljs.QUOTE_STRING_MODE,
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.COMMENT('/\\*', '\\*/', {
          contains: ['self']
        }),
        {
          className: 'number',
          begin: '\\b\\d+(\\.\\d+)?(\\w+)?',
          relevance: 0
        },
        {
          className: 'title',
          begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]* *:=',
        },
        {
          className: 'symbol',
          begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]*(:| *=>)',
        },
        {
          className: 'built_in',
          begin: '\\b[_a-zA-Z][_\\-a-zA-Z0-9]*!',
        },
      ],
      illegal: /@/
    };
  };

  // Tags used in fenced code blocks
  for (let tag of ["slint", "slint,no-preview", "slint,no-auto-preview", "slint,ignore"]) {
    hljs.registerLanguage(tag, highlight_slint);
  }


  window.addEventListener("DOMContentLoaded", () => {
    const rustDoc = document.querySelector('meta[name="generator"]')?.content == "rustdoc";
    if (rustDoc) {
      // Only highlight .slint blocks, leave the others to rustdoc
      for (slintBlock of document.querySelectorAll("[class*=language-slint]")) {
        hljs.highlightElement(slintBlock)
      }

      // Some of the rustdoc selectors require the pre element to have the rust class
      for (codeBlock of document.querySelectorAll(".language-slint.hljs")) {
        codeBlock.classList.add("rust");
        codeBlock.classList.remove("hljs");
      }

      // Change the hljs generated classes to the rustdoc
      // ones, so that the highlighting adjusts to the theme correctly.
      const highlightJSToRustDoc = [
        ["comment", "comment"],
        ["number", "number"],
        ["symbol", "struct"], // width:
        ["keyword", "kw"],
        ["built_in", "primitive"],
        ["string", "string"],
        ["title", "fnname"], // Foo :=
        ["type", "type"]
      ];

      for ([hljs_class, rustdoc_class] of highlightJSToRustDoc) {
        for (titleElement of document.querySelectorAll(`.hljs-${hljs_class}`)) {
          titleElement.classList.remove(`hljs-${hljs_class}`);
          titleElement.classList.add(rustdoc_class);
        }
      }
    } else {
      // For use with the mdbook Tutorial
      hljs.highlightAll();

      // The Sphinx/my_st generated HTML for code blocks doesn't use <code> tags, so highlight.js'
      // default selector "pre code" doesn't match. Let's do it by hand:
      for (block of document.querySelectorAll("div[class*=highlight-slint] div.highlight pre")) {
        hljs.highlightElement(block)
      }
    }

    // Fix up links that sphinx handles but for rustdoc we need to resolve manually:
    {
      let target_url = null;
      if (document.location.hostname == "snapshots.slint.dev") {
        target_url = `https://snapshots.slint.dev/master/docs/slint/`;
      } else {
        let version = document.querySelector("span.version");
        if (version !== null) {
          target_url = `https://slint.dev/releases/${version.innerText}/docs/slint/`;
        }
      }

      if (target_url !== null) {
        for (let link of document.querySelectorAll("a[href^='slint-reference:']")) {
          link.href = link.href.replace("slint-reference:", target_url);
        }
      }
    }
  });
</script>

</head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../i_slint_backend_testing/index.html"><img src="https://slint.dev/logo/slint-logo-square-light.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../i_slint_backend_testing/index.html"><img src="https://slint.dev/logo/slint-logo-square-light.svg" alt="logo"></a><h2><a href="../i_slint_backend_testing/index.html">i_<wbr>slint_<wbr>backend_<wbr>testing</a><span class="version">1.11.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#preliminary-slint-testing-api" title="Preliminary Slint Testing API">Preliminary Slint Testing API</a><ul><li><a href="#testing-backend" title="Testing Backend">Testing Backend</a></li><li><a href="#preliminary-user-interface-testing-api" title="Preliminary User Interface Testing API">Preliminary User Interface Testing API</a></li><li><a href="#simulating-events--asynchronous-testing" title="Simulating events / Asynchronous testing">Simulating events / Asynchronous testing</a></li></ul></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>i_slint_backend_testing</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/i_slint_backend_testing/lib.rs.html#4-70">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><!-- Copyright © SixtyFPS GmbH <info@slint.dev> ; SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-Slint-Royalty-free-2.0 OR LicenseRef-Slint-Software-3.0 -->
<p><strong>NOTE</strong>: This library is an <strong>internal</strong> crate of the <a href="https://slint.dev">Slint project</a>.
This crate should <strong>not be used directly</strong> by applications using Slint.
You should use the <code>slint</code> crate instead.</p>
<p><strong>WARNING</strong>: This crate does not follow the semver convention for versioning and can
only be used with <code>version = "=x.y.z"</code> in Cargo.toml.</p>
<h2 id="preliminary-slint-testing-api"><a class="doc-anchor" href="#preliminary-slint-testing-api">§</a>Preliminary Slint Testing API</h2>
<p>This crate provides the preliminary API that we’re developing to enable different
user interface (UI) testing scenarios for Slint applications.</p>
<p>To use this functionality, you need to be cautious when importing dependencies since
this crate does not adhere to semver and may introduce breaking changes in any patch release.
Additionally, the version of this crate must match the version of Slint.
To indicate that you specifically want this version, include the <code>=</code> symbol in the version string.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
slint = { version = &quot;x.y.z&quot;, ... }
i-slint-backend-testing = &quot;=x.y.z&quot;</code></pre></div><h3 id="testing-backend"><a class="doc-anchor" href="#testing-backend">§</a>Testing Backend</h3>
<p>By default, Slint applications will select a backend and renderer suitable for application display
on the screen, by means of utilizing a windowing system - if present - or directly rendering to
the framebuffer.</p>
<p>For automated testing in CI environments without a windowing system / display, it might still be
desirable to run tests. The Slint Testing Backend simulates a windowing system without requiring one:
No pixels are rendered and text is measured by a fixed font size.</p>
<p>Use <a href="fn.init_integration_test_with_system_time.html" title="fn i_slint_backend_testing::init_integration_test_with_system_time"><code>init_integration_test_with_system_time()</code></a> for <a href="https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html">integration tests</a>
where your test code requires Slint to provide an event loop, for example when spawning threads
and calling <code>slint::invoke_from_event_loop()</code>. If you want to not only simulate the windowing system but
also the system time, use <a href="fn.init_integration_test_with_mock_time.html" title="fn i_slint_backend_testing::init_integration_test_with_mock_time"><code>init_integration_test_with_mock_time()</code></a> to initialize the backend and then
call <a href="fn.mock_elapsed_time.html" title="fn i_slint_backend_testing::mock_elapsed_time"><code>mock_elapsed_time()</code></a> to advance animations and move timers closer to their next timeout.</p>
<p>Use <a href="fn.init_no_event_loop.html" title="fn i_slint_backend_testing::init_no_event_loop"><code>init_no_event_loop()</code></a> for <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit tests</a> when your test
code does not require an event loop. Note that system time is also mocked in this scenario, so use
<a href="fn.mock_elapsed_time.html" title="fn i_slint_backend_testing::mock_elapsed_time"><code>mock_elapsed_time()</code></a> to advance animations and timers.</p>
<h3 id="preliminary-user-interface-testing-api"><a class="doc-anchor" href="#preliminary-user-interface-testing-api">§</a>Preliminary User Interface Testing API</h3>
<p>We’re developing APIs to facilitate the creation of automated tests for Slint based UIs. A building block
is the ability to introspect and modify the state from within what would be a regular application process.</p>
<p>A regular application might have a <code>main()</code> entry-point like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), slint::PlatformError&gt;
{
    <span class="kw">let </span>app = App::new()<span class="question-mark">?</span>;
    <span class="comment">// ... set up state, callbacks, models, ...

    </span>app.run()
}</code></pre></div>
<p>In addition, it may be desirable to create an integration test that verifies how the application behaves when simulating user input.
The objective of the user interface testing API provided in this crate is to facilitate locating, mutation, and verifying state of
elements in your UI. <a href="struct.ElementHandle.html" title="struct i_slint_backend_testing::ElementHandle"><code>ElementHandle</code></a> provides a view for these elements.</p>
<p>The example below assumes that somewhere in the UI you have declared a <code>Button</code> with the text “Submit” and you may want to verify
how the application behaves when simulation the activation. This is done by locating and triggering it via its accessibility interface,
that every <code>Button</code> implements.</p>
<div class="example-wrap"><pre class="language-slint"><code>import { Button } from &quot;std-widgets.slint&quot;;
component Form {
    callback submit();
    VerticalLayout {
        // ...
        Button {
            text: &quot;Submit&quot;;
            clicked =&gt; { root.submit(); }
        }
    }
}

export component App {
    callback submit &lt;=&gt; form.submit;
    // ...
    form := Form {
        // ...
    }
}</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>test_basic_user_interface()
{
    i_slint_backend_testing::init_no_event_loop();
    <span class="kw">let </span>app = App::new().unwrap();
    <span class="comment">// ... set up state, callbacks, models, ...
    </span><span class="kw">let </span>submitted = std::rc::Rc::new(std::cell::RefCell::new(<span class="bool-val">false</span>));

    app.on_submit({
        <span class="kw">let </span>submitted = submitted.clone();
        <span class="kw">move </span>|| { <span class="kw-2">*</span>submitted.borrow_mut() = <span class="bool-val">true</span>; }
    });

    <span class="kw">let </span>buttons: Vec&lt;<span class="kw">_</span>&gt; = i_slint_backend_testing::ElementHandle::find_by_accessible_label(<span class="kw-2">&amp;</span>app, <span class="string">"Submit"</span>).collect();
    <span class="macro">assert_eq!</span>(buttons.len(), <span class="number">1</span>);
    <span class="kw">let </span>button = <span class="kw-2">&amp;</span>buttons[<span class="number">0</span>];

    button.invoke_accessible_default_action();

    <span class="macro">assert!</span>(<span class="kw-2">*</span>submitted.borrow());
}</code></pre></div>
<h3 id="simulating-events--asynchronous-testing"><a class="doc-anchor" href="#simulating-events--asynchronous-testing">§</a>Simulating events / Asynchronous testing</h3>
<p>When testing user interfaces it may be desirable to not only invoke accessible actions on elements, but it may also be
useful to simulate touch or mouse input. For example a mouse click on a button is a sequence:</p>
<ol>
<li>An initial mouse move event to a location over the button</li>
<li>A mouse press event.</li>
<li>In real life, a certain amount of time would elapse now.</li>
<li>Finally, the user lifts the finger again from the mouse and a mouse release event is triggered.</li>
</ol>
<p>To simulate this behaviour, <a href="struct.ElementHandle.html" title="struct i_slint_backend_testing::ElementHandle"><code>ElementHandle</code></a> provides functions such as <a href="struct.ElementHandle.html#method.single_click" title="method i_slint_backend_testing::ElementHandle::single_click"><code>ElementHandle::single_click()</code></a> and <a href="struct.ElementHandle.html#method.double_click" title="method i_slint_backend_testing::ElementHandle::double_click"><code>ElementHandle::double_click()</code></a>.
Since these functions simulate a sequence of events with a period of idle time between the events, these functions are <a href="https://doc.rust-lang.org/std/keyword.async.html">async</a>
and return a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>std::future::Future</code></a>, which resolves when the last event in the sequence was sent.</p>
<p>Calling these functions requires running the test function itself as a future and running an event loop in the background.
This can be accomplished using <code>slint::spawn_local()</code>, <code>slint::run_event_loop()</code>, and <code>slint::quit_event_loop()</code>. The following
example wraps the core functions for testing in an async closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">use </span>slint::platform::PointerEventButton;

<span class="attr">#[test]
</span><span class="kw">fn </span>test_click() {
    i_slint_backend_testing::init_integration_test_with_system_time();

    slint::spawn_local(<span class="kw">async move </span>{
        <span class="macro">slint::slint!</span> {
            export component App inherits Window {
                out property &lt;int&gt; click-count: <span class="number">0</span>;
                ta := TouchArea {
                    clicked =&gt; { root.click-count += <span class="number">1</span>; }
                }
            }
        }

        <span class="kw">let </span>app = App::new().unwrap();

        <span class="kw">let </span><span class="kw-2">mut </span>it = ElementHandle::find_by_element_id(<span class="kw-2">&amp;</span>app, <span class="string">"App::ta"</span>);
        <span class="kw">let </span>elem = it.next().unwrap();
        <span class="macro">assert!</span>(it.next().is_none());

        <span class="macro">assert_eq!</span>(app.get_click_count(), <span class="number">0</span>);
        elem.single_click(PointerEventButton::Left).<span class="kw">await</span>;
        <span class="macro">assert_eq!</span>(app.get_click_count(), <span class="number">1</span>);

        slint::quit_event_loop().unwrap();
    })
    .unwrap();
    slint::run_event_loop().unwrap();
}</code></pre></div>
<p>After initializing the testing backend with support for using the system time, an async
closure is spawned, which does the actual testing. In the subsequent <code>run_event_loop()</code> call,
the event loop is started, and that will start polling the async closure passed to <code>spawn_local()</code>.</p>
<p>In this closure we can now call <code>.await</code> on the future <a href="struct.ElementHandle.html#method.single_click" title="method i_slint_backend_testing::ElementHandle::single_click"><code>ElementHandle::single_click()</code></a> returns, which
will keep running the event loop until the click is complete, and then continue with the test function.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ElementHandle.html" title="struct i_slint_backend_testing::ElementHandle">Element<wbr>Handle</a></dt><dd><code>ElementHandle</code> wraps an existing element in a Slint UI. An ElementHandle does not keep
the corresponding element in the UI alive. Use <a href="struct.ElementHandle.html#method.is_valid" title="method i_slint_backend_testing::ElementHandle::is_valid"><code>Self::is_valid()</code></a> to verify that
it is still alive.</dd><dt><a class="struct" href="struct.ElementQuery.html" title="struct i_slint_backend_testing::ElementQuery">Element<wbr>Query</a></dt><dd>Use ElementQuery to form a query into the tree of UI elements and then locate one or multiple
matching elements.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AccessibleRole.html" title="enum i_slint_backend_testing::AccessibleRole">Accessible<wbr>Role</a></dt><dd>This enum represents the different values for the <code>accessible-role</code> property, used to describe the
role of an element in the context of assistive technology such as screen readers.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ElementRoot.html" title="trait i_slint_backend_testing::ElementRoot">Element<wbr>Root</a></dt><dd>Trait for type that can be searched for element. This is implemented for everything that implements [<code>ComponentHandle</code>]</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.init_integration_test_with_mock_time.html" title="fn i_slint_backend_testing::init_integration_test_with_mock_time">init_<wbr>integration_<wbr>test_<wbr>with_<wbr>mock_<wbr>time</a></dt><dd>Initialize the testing backend with support for simple event loop.
This function can only be called once per process, so make sure to use integration
tests with only one <code>#[test]</code> function. (Or in a doc test)
Must be called before any call that would otherwise initialize the rendering backend.
Calling it when the rendering backend is already initialized will panic.</dd><dt><a class="fn" href="fn.init_integration_test_with_system_time.html" title="fn i_slint_backend_testing::init_integration_test_with_system_time">init_<wbr>integration_<wbr>test_<wbr>with_<wbr>system_<wbr>time</a></dt><dd>Initialize the testing backend with support for simple event loop.
This function can only be called once per process, so make sure to use integration
tests with only one <code>#[test]</code> function. (Or in a doc test)
Must be called before any call that would otherwise initialize the rendering backend.
Calling it when the rendering backend is already initialized will panic.</dd><dt><a class="fn" href="fn.init_no_event_loop.html" title="fn i_slint_backend_testing::init_no_event_loop">init_<wbr>no_<wbr>event_<wbr>loop</a></dt><dd>Initialize the testing backend without support for event loop.
This means that each test thread can use its own backend, but global functions that needs
an event loop such as <code>slint::invoke_from_event_loop</code> or <code>Timer</code>s won’t work.
Must be called before any call that would otherwise initialize the rendering backend.
Calling it when the rendering backend is already initialized will panic.</dd><dt><a class="fn" href="fn.mock_elapsed_time.html" title="fn i_slint_backend_testing::mock_elapsed_time">mock_<wbr>elapsed_<wbr>time</a></dt><dd>Advance the simulated mock time by the specified duration. Use in combination with
<a href="fn.init_integration_test_with_mock_time.html" title="fn i_slint_backend_testing::init_integration_test_with_mock_time"><code>init_integration_test_with_mock_time()</code></a> or <a href="fn.init_no_event_loop.html" title="fn i_slint_backend_testing::init_no_event_loop"><code>init_no_event_loop()</code></a>.</dd></dl></section></div></main></body></html>